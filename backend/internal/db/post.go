package db

import (
	"fmt"
	"strings"

	"github.com/genjidb/genji"
	"github.com/genjidb/genji/document"
	"github.com/genjidb/genji/types"
	"go.uber.org/zap"
)

// Post is the DB model describing a single post.
type Post struct {
	ID              uint64
	Title           string
	Description     string
	Location        string
	ImageBucket     string `genji:"image_bucket"`
	ImageID         string `genji:"image_id"`
	CreatorUsername string `genji:"creator_username"`
	CreatedAt       int64  `genji:"created_at"`
	Likes           uint64
	Liked           bool
}

// CreatePost creates a new post. The ID and CreatedAt are autogenerated.
// If the user specified as the creator doesn't exist, a NotFound error is returned.
func (g *Genji) CreatePost(post Post) error {
	const query = `
			insert into post (
				id, title, description, location, image_bucket, image_id, creator_username, created_at
			)	values (
				next value for post_id,
				?, ?, ?, ?, ?, ?, ?
			)
		`

	return g.withTx(true, func(tx *genji.Tx) error {
		userExists, err := g.checkExists(tx, "user", "username", post.CreatorUsername)
		if err != nil {
			return err
		} else if !userExists {
			return notFound("user")
		}

		return wrapError("CreatePost", tx.Exec(query,
			post.Title, post.Description, post.Location, post.ImageBucket, post.ImageID, post.CreatorUsername, now(),
		))
	})
}

// ToggleLikedPost toggles the post's "liked" label by the user with the specified username.
// If this post is already marked as liked by the user, it is unliked.
// If no such post or user exists, a NotFound error is returned.
func (g *Genji) ToggleLikedPost(username string, postID uint64) error {
	const (
		addQuery    = `insert into post_likes (username, post_id) values (?, ?)`
		deleteQuery = `delete from post_likes where username = ? and post_id = ?`
	)

	return g.withTx(true, func(tx *genji.Tx) error {
		userExists, err := g.checkExists(tx, "user", "username", username)
		if err != nil {
			return err
		} else if !userExists {
			return notFound("user")
		}

		postExists, err := g.checkExists(tx, "post", "id", postID)
		if err != nil {
			return err
		} else if !postExists {
			return notFound("post")
		}

		// If a post is already liked, then remove that label instead of adding it
		toggleErr := wrapError("AddLikedPost.add", tx.Exec(addQuery, username, postID))
		if IsAlreadyExists(toggleErr) {
			toggleErr = wrapError("AddLikedPost.delete", tx.Exec(deleteQuery, username, postID))
		}

		return toggleErr
	})
}

// ListPostsFirst lists the first page of posts, possibly with a username filter.
func (g *Genji) ListPostsFirst(username string, limit int32, ourUsername string) ([]Post, int64, error) {
	const query = `select * from post where (? = "" or creator_username = ?) order by created_at desc limit ?`

	res, err := g.db.Query(query, username, username, limit)
	if err != nil {
		return nil, 0, wrapError("ListPosts", err)
	}

	return g.scanListPostsResult(res, ourUsername)
}

// ListPostsNext lists the second and further pages of posts, possible with a username filter.
func (g *Genji) ListPostsNext(username string, before int64, limit int32, ourUsername string) ([]Post, int64, error) {
	const query = `select * from post where (? = "" or creator_username = ?) and created_at < ? order by created_at desc limit ?`

	res, err := g.db.Query(query, username, username, before, limit)
	if err != nil {
		return nil, 0, wrapError("ListPosts", err)
	}

	return g.scanListPostsResult(res, ourUsername)
}

func (g *Genji) getPostLikes(postId uint64) (uint64, error) {
	const query = `select count(*) from post_likes where post_id = ?`

	var likes uint64
	doc, err := g.db.QueryDocument(query, postId)
	if err != nil {
		return 0, wrapError("getPostLikes", err)
	}

	return likes, document.Scan(doc, &likes)
}

func (g *Genji) getPostLiked(postId uint64, username string) (bool, error) {
	const query = `select count(*) from post_likes where post_id = ? and username = ?`

	var liked uint64
	doc, err := g.db.QueryDocument(query, postId, username)
	if err != nil {
		return false, wrapError("getPostLiked", err)
	}

	return liked > 0, document.Scan(doc, &liked)
}

func (g *Genji) scanListPostsResult(res *genji.Result, ourUsername string) ([]Post, int64, error) {
	var posts []Post
	if err := res.Iterate(func(d types.Document) error {
		zap.L().Info("ListPosts", zap.Any("d", d))
		var post Post
		if err := document.StructScan(d, &post); err != nil {
			return wrapScanError("ListPosts", err)
		}

		// fuck genjidb
		likes, err := g.getPostLikes(post.ID)
		if err != nil {
			return wrapError("ListPosts", err)
		}
		liked, err := g.getPostLiked(post.ID, ourUsername)
		if err != nil {
			return wrapError("ListPosts", err)
		}

		// Need to copy strings manually because of GenjiDB bug: https://github.com/genjidb/genji/issues/497
		post.Title = strings.Clone(post.Title)
		post.Description = strings.Clone(post.Description)
		post.Location = strings.Clone(post.Location)
		post.ImageBucket = strings.Clone(post.ImageBucket)
		post.ImageID = strings.Clone(post.ImageID)
		post.CreatorUsername = strings.Clone(post.CreatorUsername)
		post.Likes = likes
		post.Liked = liked

		posts = append(posts, post)
		return nil
	}); err != nil {
		return nil, 0, err
	}

	// Prepare next "page id" if any results are available
	var nextBefore int64
	if len(posts) > 0 {
		nextBefore = posts[len(posts)-1].CreatedAt
	}

	zap.L().Info("ListPosts", zap.Any("d", posts))

	return posts, nextBefore, nil
}

// checkExists is a helper for checking whether an entity exists in a transaction
func (g *Genji) checkExists(tx *genji.Tx, table, column string, id any) (bool, error) {
	query := fmt.Sprintf(`select true from %s where %s = ?`, table, column)

	var exists bool
	existsCheckDoc, err := tx.QueryDocument(query, id)
	if err != nil {
		return false, wrapError("checkExists", err)
	}

	if err := document.Scan(existsCheckDoc, &exists); err != nil {
		return false, wrapScanError("checkExists", err)
	}

	return exists, nil
}
